
public class BinaryTree {

	Node head;
	int size;
	String builder;
	Node root; 

	public BinaryTree() {
		head = null;
		size = 0;
		root = head; 
	}

	/**
	 * Add node to the tree! keeps the tree in a sorted fashion every node to the
	 * right of a node is >= to that node every node to the left of a node is <= to
	 * that node
	 * 
	 * @param args
	 */

	public void add(Node n) {
		if (head == null) {
			head = n;
			size++;
		} else {
			Node prev = null;
			Node curr = head;
			while (curr != null) {
				prev = curr;
				if (curr.getData() > n.getData()) {
					curr = curr.left;
				} else {
					curr = curr.right;
				}
			}

			if (prev.getData() <= n.getData()) {
				prev.right = n;
				size++;
			} else {
				prev.left = n;
				size++;
			}
		}
	}

	/*public void print() {
		// print all the elements- no specifics for time being
		// for testing purposes
		System.out.print(head);
		Node curr = head;
		while (curr.right != null) {
			System.out.println(curr.right);
			curr = curr.right;
		}
		while (curr.left != null) {
			System.out.println(curr.left);
			head = curr.left;
		}

	}
	*/

	public static void main(String[] args) {
		// TODO Auto-generated method stub
			
		//Write blocks of code to use binary tree you implement
		//try adding elements and printing tree
		
		BinaryTree test = new BinaryTree(); 
		Node n1 = new Node(3); 
		Node n2 = new Node(1);
		Node n3 = new Node(5);
		Node n4 = new Node(2);
		
		test.add(n1);
		test.add(n2);
		test.add(n3);
		test.add(n4);
		
		//test.print(); 
		System.out.println(test.bfs()); 
		System.out.println(test.dfs()); 
		
	}

	public String bfs() {
		// return a string representation of the nodes
		// in a breadth-first-traversal
		int h = height(head);
		for (int i = 1; i <= h; i++) {
			printCurrentLevel(head, i);
		}
		return builder;
	}

	public void printLevelOrder() {
		int h = height(root); //head
		for (int i = 1; i <= h; i++)
			printCurrentLevel(root, i); //head
	}

	/*
	 * Compute the "height" of a tree -- the number of nodes along the longest path
	 * from the root node down to the farthest leaf node.
	 */
	public int height(Node root) {
		if (root == null)
			return 0;
		else {
			/* compute height of each subtree */
			int lheight = height(root.left);
			int rheight = height(root.right);

			/* use the larger one */
			if (lheight > rheight)
				return (lheight + 1);
			else
				return (rheight + 1);
		}
	}

	/* Print nodes at the current level */
	public void printCurrentLevel(Node root, int level) {
		if (root == null)
			return;
		if (level == 1)
			builder += root.getData() + " ";
		else if (level > 1) {
			printCurrentLevel(root.left, level - 1);
			printCurrentLevel(root.right, level - 1);
		}
	}

	// pre-order depth-first-search traversal

	public String dfs() {

		return printDepOrder(head);

	}

	public String printDepOrder(Node node) {
		if (node == null) {
			return "";
		}
		return ((node.getData() + " ") + printDepOrder(node.left) + printDepOrder(node.right));

	}

	public String printDepOrder() {
		return printDepOrder(head);
	}

}
